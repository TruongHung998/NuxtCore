# Nuxt.js Development Rules for Cursor IDE

## Project Overview
You are working on a Nuxt.js application. Follow these guidelines for consistent, maintainable, and performant code.

## Code Style & Formatting

### General
- Use TypeScript for all new files
- Use 2 spaces for indentation
- Use single quotes for strings
- Add trailing commas in objects and arrays
- Use semicolons consistently
- Prefer const over let, avoid var
- Use descriptive variable and function names

### Vue/Nuxt Specific
- Use Composition API with `<script setup>` syntax
- Prefer auto-imports over explicit imports when available
- Use PascalCase for component names
- Use kebab-case for file names
- Use camelCase for variables and functions

## File Structure & Organization

### Directory Structure
```
/
├── assets/          # Uncompiled assets (SCSS, images, fonts)
├── components/      # Vue components
│   ├── ui/         # Reusable UI components
│   └── layout/     # Layout-specific components
├── composables/     # Composition API composables
├── content/         # Nuxt Content files (if using @nuxt/content)
├── layouts/         # Application layouts
├── middleware/      # Route middleware
├── pages/          # Application routes
├── plugins/        # Nuxt plugins
├── public/         # Static files
├── server/         # Server-side code
│   └── api/       # API routes
├── stores/         # Pinia stores (if using state management)
└── utils/          # Utility functions
```

### Naming Conventions
- Components: `PascalCase.vue` (e.g., `UserProfile.vue`)
- Pages: `kebab-case.vue` (e.g., `user-profile.vue`)
- Composables: `use + PascalCase` (e.g., `useUserAuth.ts`)
- Stores: `use + PascalCase + Store` (e.g., `useUserStore.ts`)
- Utils: `camelCase` (e.g., `formatDate.ts`)

## Component Guidelines

### Template Structure
```vue
<template>
  <div class="component-name">
    <!-- Use semantic HTML -->
    <!-- Keep templates clean and readable -->
  </div>
</template>
```

### Script Setup
```vue
<script setup lang="ts">
// 1. Type definitions and interfaces
interface Props {
  title: string
  isVisible?: boolean
}

// 2. Props and emits
const props = withDefaults(defineProps<Props>(), {
  isVisible: true
})

const emit = defineEmits<{
  update: [value: string]
  close: []
}>()

// 3. Composables and stores
const { $api } = useNuxtApp()
const userStore = useUserStore()

// 4. Reactive data
const isLoading = ref(false)
const data = reactive({})

// 5. Computed properties
const computedValue = computed(() => {
  return props.title.toUpperCase()
})

// 6. Methods
const handleClick = () => {
  emit('update', 'new-value')
}

// 7. Lifecycle hooks
onMounted(() => {
  // Component initialization
})
</script>
```

### Style Guidelines
```vue
<style scoped lang="scss">
.component-name {
  // Use BEM methodology or utility classes
  // Prefer CSS custom properties for theming
  // Use logical properties (margin-inline, padding-block)
}
</style>
```

## Nuxt.js Specific Best Practices

### Pages & Routing
- Use file-based routing
- Implement proper meta tags with `useSeoMeta()` or `useHead()`
- Use `definePageMeta()` for page-specific configuration
- Implement proper error handling with error.vue

### Server-Side Rendering (SSR)
- Use `useState()` for shared state between client and server
- Implement proper hydration with `<ClientOnly>` when needed
- Use `process.client` and `process.server` guards appropriately
- Optimize initial payload size

### Data Fetching
```typescript
// Prefer server-side data fetching
const { data, error, pending } = await $fetch('/api/users')

// Use proper error handling
const { data: users, error } = await useFetch('/api/users', {
  onRequestError: ({ error }) => {
    console.error('Request failed:', error)
  }
})

// Implement loading states
if (pending.value) {
  // Show loading spinner
}
```

### Performance Optimization
- Use `lazy: true` for non-critical components
- Implement proper image optimization with `<NuxtImg>`
- Use `preload` and `prefetch` for critical resources
- Minimize bundle size with proper tree-shaking

## State Management (Pinia)

### Store Structure
```typescript
export const useUserStore = defineStore('user', () => {
  // State
  const user = ref<User | null>(null)
  const isAuthenticated = computed(() => !!user.value)
  
  // Actions
  const login = async (credentials: LoginCredentials) => {
    try {
      const response = await $fetch('/api/auth/login', {
        method: 'POST',
        body: credentials
      })
      user.value = response.user
    } catch (error) {
      throw error
    }
  }
  
  const logout = () => {
    user.value = null
    navigateTo('/login')
  }
  
  return {
    user: readonly(user),
    isAuthenticated,
    login,
    logout
  }
})
```

## API & Server Routes

### Server API Routes
```typescript
// server/api/users.get.ts
export default defineEventHandler(async (event) => {
  try {
    // Validate request
    const query = getQuery(event)
    
    // Business logic
    const users = await getUsersFromDatabase(query)
    
    return {
      data: users,
      success: true
    }
  } catch (error) {
    throw createError({
      statusCode: 500,
      statusMessage: 'Failed to fetch users'
    })
  }
})
```

### Error Handling
- Use `throw createError()` for API errors
- Implement global error handling
- Provide meaningful error messages
- Log errors appropriately

## TypeScript Guidelines

### Type Definitions
```typescript
// types/index.ts
export interface User {
  id: string
  name: string
  email: string
  role: 'admin' | 'user'
  createdAt: Date
}

export interface ApiResponse<T> {
  data: T
  success: boolean
  message?: string
}
```

### Composables
```typescript
// composables/useAuth.ts
export const useAuth = () => {
  const user = useState<User | null>('user', () => null)
  
  const login = async (credentials: LoginCredentials): Promise<void> => {
    // Implementation
  }
  
  const logout = (): void => {
    user.value = null
    navigateTo('/login')
  }
  
  return {
    user: readonly(user),
    login,
    logout
  }
}
```

## Testing Guidelines

### Unit Tests
- Test composables independently
- Mock external dependencies
- Test edge cases and error scenarios
- Use descriptive test names

### E2E Tests
- Test critical user journeys
- Test across different devices/browsers
- Implement proper test data setup/teardown

## Security Best Practices

- Validate all user inputs
- Use HTTPS in production
- Implement proper CORS policies
- Sanitize data before rendering
- Use environment variables for sensitive data
- Implement rate limiting for API routes

## Performance Guidelines

### Bundle Optimization
- Use dynamic imports for large components
- Implement code splitting at the route level
- Minimize third-party dependencies
- Use bundle analyzer to identify bottlenecks

### Runtime Performance
- Avoid unnecessary reactivity
- Use `shallowRef` for large objects when appropriate
- Implement virtual scrolling for large lists
- Optimize images and assets

## Development Workflow

### Git Practices
- Use conventional commits
- Create feature branches
- Write descriptive commit messages
- Review code before merging

### Code Quality
- Use ESLint and Prettier
- Run type checking with TypeScript
- Write unit tests for critical functions
- Document complex logic with comments

## Environment Configuration

### Development
```bash
# .env.development
NUXT_API_BASE_URL=http://localhost:3001
NUXT_PUBLIC_APP_NAME="My App (Dev)"
```

### Production
```bash
# .env.production
NUXT_API_BASE_URL=https://api.myapp.com
NUXT_PUBLIC_APP_NAME="My App"
```

## Common Patterns to Follow

### Loading States
```vue
<template>
  <div>
    <div v-if="pending">Loading...</div>
    <div v-else-if="error">Error: {{ error.message }}</div>
    <div v-else>{{ data }}</div>
  </div>
</template>
```

### Form Handling
```vue
<script setup lang="ts">
const form = reactive({
  name: '',
  email: ''
})

const errors = ref<Record<string, string>>({})

const submitForm = async () => {
  errors.value = {}
  
  try {
    await $fetch('/api/submit', {
      method: 'POST',
      body: form
    })
  } catch (error) {
    // Handle validation errors
  }
}
</script>
```

## What to Avoid

- Don't use `any` type in TypeScript
- Don't mutate props directly
- Don't use `document` or `window` without client-side guards
- Don't ignore TypeScript errors
- Don't skip proper error handling
- Don't use inline styles excessively
- Don't create overly complex components
- Don't forget to clean up event listeners and subscriptions

## Additional Resources

- Always refer to the official Nuxt.js documentation
- Follow Vue.js best practices
- Use Nuxt DevTools for debugging
- Implement proper SEO with meta tags
- Consider accessibility (a11y) in component design